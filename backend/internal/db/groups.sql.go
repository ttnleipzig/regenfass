// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: groups.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDeviceToGroup = `-- name: AddDeviceToGroup :exec
INSERT INTO "device_group" (device_id, group_id, is_readonly)
VALUES ($1, $2, $3)
ON CONFLICT (device_id, group_id)
DO UPDATE SET
	is_readonly = EXCLUDED.is_readonly
`

type AddDeviceToGroupParams struct {
	DeviceID   pgtype.UUID
	GroupID    pgtype.UUID
	IsReadonly bool
}

func (q *Queries) AddDeviceToGroup(ctx context.Context, arg AddDeviceToGroupParams) error {
	_, err := q.db.Exec(ctx, addDeviceToGroup, arg.DeviceID, arg.GroupID, arg.IsReadonly)
	return err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO "group" (name) VALUES ($1) RETURNING id, rw_token, ro_token
`

type CreateGroupRow struct {
	ID      pgtype.UUID
	RwToken string
	RoToken string
}

func (q *Queries) CreateGroup(ctx context.Context, name string) (CreateGroupRow, error) {
	row := q.db.QueryRow(ctx, createGroup, name)
	var i CreateGroupRow
	err := row.Scan(&i.ID, &i.RwToken, &i.RoToken)
	return i, err
}

const getDevicesInGroupByGroupID = `-- name: GetDevicesInGroupByGroupID :many
SELECT
	(CASE
		WHEN device_group.is_readonly OR $2 THEN device.ro_token
		ELSE device.rw_token
	END)::TEXT AS token,
	(CASE
		WHEN device_group.is_readonly OR $2 THEN true
		ELSE false
	END)::BOOLEAN AS is_readonly
FROM device_group
JOIN device ON device.id = device_group.device_id
WHERE device_group.group_id = $1
`

type GetDevicesInGroupByGroupIDParams struct {
	GroupID pgtype.UUID
	Column2 string
}

type GetDevicesInGroupByGroupIDRow struct {
	Token      string
	IsReadonly bool
}

func (q *Queries) GetDevicesInGroupByGroupID(ctx context.Context, arg GetDevicesInGroupByGroupIDParams) ([]GetDevicesInGroupByGroupIDRow, error) {
	rows, err := q.db.Query(ctx, getDevicesInGroupByGroupID, arg.GroupID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDevicesInGroupByGroupIDRow
	for rows.Next() {
		var i GetDevicesInGroupByGroupIDRow
		if err := rows.Scan(&i.Token, &i.IsReadonly); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupByEitherToken = `-- name: GetGroupByEitherToken :one
SELECT id, name, rw_token, ro_token, (ro_token = $1) AS is_readonly FROM "group" WHERE ro_token = $1 OR rw_token = $1
`

type GetGroupByEitherTokenRow struct {
	ID         pgtype.UUID
	Name       string
	RwToken    string
	RoToken    string
	IsReadonly bool
}

func (q *Queries) GetGroupByEitherToken(ctx context.Context, roToken string) (GetGroupByEitherTokenRow, error) {
	row := q.db.QueryRow(ctx, getGroupByEitherToken, roToken)
	var i GetGroupByEitherTokenRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RwToken,
		&i.RoToken,
		&i.IsReadonly,
	)
	return i, err
}
